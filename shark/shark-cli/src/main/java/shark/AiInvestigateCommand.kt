package shark

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.option
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.util.concurrent.CompletableFuture
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put
import shark.HeapObject.HeapClass
import shark.HeapObject.HeapInstance
import shark.HeapObject.HeapObjectArray
import shark.HeapObject.HeapPrimitiveArray
import shark.HprofHeapGraph.Companion.openHeapGraph
import shark.LeakTraceObject.LeakingStatus
import shark.LeakTraceObject.LeakingStatus.LEAKING
import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
import shark.SharkCliCommand.Companion.echo
import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
import shark.SharkCliCommand.Companion.sharkCliParams
import shark.ValueHolder.ReferenceHolder

class AiInvestigateCommand : CliktCommand(
  name = "ai-investigate",
  help = "AI-driven heap leak investigation skill. Run with --help to see full instructions."
) {

  override fun getFormattedHelp(): String = INSTRUCTIONS

  // --instructions-only prints the raw INSTRUCTIONS string and returns normally from run().
  // This lets the shark-ai-investigate wrapper print instructions before starting the daemon.
  private val instructionsOnly by option(
    "--instructions-only",
    help = "Print instructions and exit without starting the daemon (used by shark-ai-investigate)"
  ).flag()

  // Unique session shortcode generated by shark-ai-investigate and passed to every daemon.
  // Also required as the first argument to ai-investigate-cmd.
  private val session by option(
    "--session",
    help = "Session shortcode generated by shark-ai-investigate"
  )

  override fun run() {
    if (instructionsOnly) {
      echo(INSTRUCTIONS)
      return
    }

    val shortcode = session ?: error("--session is required (use shark-ai-investigate to start a session)")
    val inPath = "/tmp/shark-$shortcode.in"
    val outPath = "/tmp/shark-$shortcode.out"

    // Delete stale pipes immediately so the wrapper's poll cannot mistake a
    // leftover file from a previous session for a ready signal.
    File(inPath).delete()
    File(outPath).delete()

    val params = context.sharkCliParams
    val heapDumpFile = retrieveHeapDumpFile(params)
    val proguardMapping = params.obfuscationMappingPath?.let {
      ProguardMappingReader(it.inputStream()).readProguardMapping()
    }

    heapDumpFile.openHeapGraph(proguardMapping).use { graph ->
      val investigationSession = LeakInvestigationSession(
        referenceMatchers = AndroidReferenceMatchers.appDefaults,
        objectInspectors = AndroidObjectInspectors.appDefaults
      )

      val leakingObjectIds = FilteringLeakingObjectFinder(
        AndroidObjectInspectors.appLeakingObjectFilters
      ).findLeakingObjectIds(graph)

      val analysis = investigationSession.analyze(graph, leakingObjectIds)

      // Create named pipes after analysis so the wrapper's pipe-existence check
      // doubles as a signal that the heap is loaded and the daemon is ready.
      ProcessBuilder("mkfifo", inPath, outPath).start().waitFor()
      Runtime.getRuntime().addShutdownHook(Thread {
        File(inPath).delete()
        File(outPath).delete()
      })

      val state = SessionState(graph, investigationSession, analysis, heapDumpFile.absolutePath)
      state.runDaemon(inPath, outPath)
    }
  }
}

@Suppress("MaxLineLength")
private val INSTRUCTIONS = """
  |AI AGENT SKILL — Android Memory Leak Investigation
  |
  |  You are reading these instructions because you ran shark-ai-investigate.
  |  The heap is being analyzed in the background. Your session shortcode will
  |  be printed below when analysis is complete — use it in every command.
  |
  |  To skip these instructions next time: add --no-help to your command.
  |
  |MANDATORY RULES — VIOLATIONS INVALIDATE THE INVESTIGATION
  |
  |  1. Do NOT declare any conclusion until "progressPct" reaches 100.
  |     The initial trace statuses are computed by heuristics and are often
  |     incomplete. Many nodes start as UNKNOWN. That is your work to do.
  |
  |  2. Do NOT mark any node without first running "fields N" on it.
  |     Runtime field state is the primary evidence. Source code tells you
  |     what fields mean; the heap tells you what they actually are.
  |
  |  3. Do NOT mark any node without first reading its class source.
  |     For app/library classes: search local files in this repository first.
  |     If the class is not found locally, use GitHub search or other code
  |     search tools to locate the source (e.g. GitHub code search, grep.app).
  |     For Android Framework classes: https://cs.android.com/search?q=ClassName.java
  |     (e.g. View.java, Fragment.java, Activity.java, Window.java)
  |
  |  4. Always supply a concrete reason when marking — cite specific field
  |     values or source code facts. Never write "unknown", "TBD", or guess.
  |
  |  5. Work the UNKNOWN nodes one at a time using bisection. Do not skip
  |     ahead or batch-mark nodes without individual evidence.
  |
  |CONTEXT
  |
  |  This command must be run from the root of the application's source
  |  repository so the agent can read source files as part of the loop.
  |  The heap dump and the source tree are used together throughout.
  |
  |IF shark-ai-investigate FAILS TO START
  |
  |  If running shark-ai-investigate produces any error output, or does not
  |  print SHORT_CODE=..., STOP IMMEDIATELY.
  |  Do not attempt any commands. Tell the user exactly what error you saw.
  |
  |HOW TO SEND COMMANDS
  |
  |  Your session shortcode is printed after these instructions, e.g.:
  |    SHORT_CODE=f3a91b2c
  |  The shortcode is different every session. Use the actual value you received
  |  (shown below), not the example above.
  |
  |  In every example that follows, replace <shortcode> with your actual value.
  |
  |Commands — send with: shark-ai-investigate cmd <shortcode> <command>
  |
  |  TRACE NAVIGATION
  |  trace                         Show current leak trace JSON
  |  human-readable-trace          Show trace as formatted by LeakCanary (for human sharing)
  |  summary                       List all leak groups
  |  select-group N                Switch to leak group N
  |  select-trace N                Switch to trace instance N in current group
  |
  |  NODE STATUS OVERRIDES  (bisect the UNKNOWN window to find the leak)
  |  mark-leaking N REASON         Override node N -> LEAKING (reason required)
  |  mark-not-leaking N REASON     Override node N -> NOT_LEAKING (reason required)
  |  mark-unknown N                Remove override for node N
  |
  |  HEAP QUERIES
  |  node N                        Class, objectId, leaking status & labels for node N
  |  fields N                      Instance fields of trace node N
  |  fields @ID                    Instance fields of any object by heap ID
  |  instances CLASS_NAME          All instances of a class in the heap
  |  string @ID                    Read object as Java String
  |  referrers @ID                 Objects holding a reference to @ID (slow scan)
  |  retained-size @ID             Retained size of @ID: own size + all objects it exclusively dominates (slow scan)
  |
  |  ping                          Confirm daemon is alive; prints the heap dump path
  |  help                          Show these full instructions
  |  close-session                 Stop the daemon and clean up named pipes
  |
  |Node indices: 0 = GC root, last = leaking object (from "nodes" array in JSON).
  |Heap IDs come from the "objectId" field in JSON responses.
  |
  |THE THREE-ZONE MODEL
  |
  |  A trace is a reference chain from a GC root to a retained object.
  |  Every node has one of three statuses:
  |
  |    NOT_LEAKING  This object should be alive. Marking a node NOT_LEAKING
  |                 automatically forces all nodes above it to NOT_LEAKING.
  |
  |    LEAKING      This object should have been GC'd. The bottom node is
  |                 always LEAKING. Marking a node LEAKING automatically
  |                 forces all nodes below it to LEAKING.
  |
  |    UNKNOWN      Status not yet determined. These are your targets.
  |
  |  The leak is ONE bad reference: the crossing from the last NOT_LEAKING
  |  node to the first LEAKING node. Your job is to eliminate every UNKNOWN
  |  until that boundary is unambiguous.
  |
  |THE INVESTIGATION ALGORITHM — run this loop until progressPct reaches 100
  |
  |  STEP 0 — Verify the session (do this once, before anything else)
  |    Run: shark-ai-investigate cmd <shortcode> ping
  |    The response contains "heapDumpPath". Verify it matches the file the
  |    user asked you to analyze. If you get any error, or the path does not
  |    match, STOP and tell the user before proceeding.
  |
  |  STEP 1 — Check state
  |    Run: shark-ai-investigate cmd <shortcode> trace
  |    Check "progressPct". When it reaches 100, go to WIN CONDITION.
  |    Otherwise scan "nodes" for entries where "leakingStatus" is "UNKNOWN".
  |
  |  STEP 2 — Pick the target node (bisect)
  |    Find the range of UNKNOWN nodes (from suspectWindowStart onward).
  |    Pick the node at the midpoint of that range.
  |    This collapses half the UNKNOWN window per iteration.
  |
  |  STEP 3 — Gather evidence (BOTH of these are required)
  |    a. Read the class source. Search the local repo first; if not found,
  |       use GitHub search or other code search tools (e.g. grep.app) to
  |       locate it, or check cs.android.com for Android Framework classes.
  |       Understand what keeps this object alive vs. what should signal that
  |       it is done (destroyed, detached, finished, etc.).
  |    b. Run: shark-ai-investigate cmd <shortcode> fields <N>
  |       Look for lifecycle indicators: mDestroyed=true, mDetached=true,
  |       mFinished=true, mAttachInfo==null (View not attached to a window),
  |       mParent==null, listener fields that are null/cleared, negative or
  |       zeroed counters, closed/cancelled flags.
  |       If a field references another object worth inspecting:
  |       Run: shark-ai-investigate cmd <shortcode> fields @<objectId>
  |
  |  STEP 4 — Mark the node
  |    Combine source knowledge + observed field values to answer:
  |    "Should this specific instance be alive right now?"
  |      YES → shark-ai-investigate cmd <shortcode> mark-not-leaking <N> <reason>
  |      NO  → shark-ai-investigate cmd <shortcode> mark-leaking <N> <reason>
  |    Reason must cite specific field values or source code facts.
  |    Example reasons (derive yours from actual evidence):
  |      "mDestroyed is true, Activity has been destroyed"
  |      "mAttachInfo is null, View is detached from window"
  |      "held by Application singleton which never dies"
  |      "Fragment.mAdded is false and mDetached is true"
  |
  |  STEP 5 — Repeat
  |    After marking, the trace re-renders with propagated statuses.
  |    Return to STEP 1.
  |
  |WIN CONDITION — progressPct: 100
  |
  |  When progressPct reaches 100 (no UNKNOWN nodes remain), "leakFound"
  |  becomes true and "culpritReferenceIndex" points to the bad reference —
  |  the one crossing from the last NOT_LEAKING node to the first LEAKING node.
  |
  |AFTER THE WIN
  |
  |  1. Identify the culprit: run "node N" at culpritReferenceIndex.
  |
  |  2. Read the source of the class holding that field. Find why the
  |     reference is not cleared. Common root causes:
  |       - Listener/callback registered but never unregistered
  |       - Static or application-scoped field holding a short-lived object
  |       - Anonymous/inner class implicitly capturing the outer instance
  |       - Handler or Runnable with a pending message outliving its host
  |       - Coroutine or background thread holding a reference past teardown
  |
  |  3. Make a fix hypothesis. The session remains open. Continue with "fields", "instances", and
  |     "referrers", as well as exploring code, to gather further evidence or verify the fix
  |     hypothesis.
  |
  |  4. Run retained-size using "firstLeakingObjectId" from the trace JSON:
  |       shark-ai-investigate cmd <shortcode> retained-size @<firstLeakingObjectId>
  |     Interpret the result:
  |       - If no UNKNOWN nodes remain (progressPct == 100):
  |           "retainedSize" is the exact memory this leak is retaining.
  |       - If UNKNOWN nodes remain:
  |           "retainedSize" is a lower bound — actual retained memory may be higher.
  |     Record this value; it MUST appear in your final reply to the human.
  |
  |  5. Once done, run: shark-ai-investigate cmd <shortcode> human-readable-trace
  |     Copy the output verbatim into your reply to the human.
  |     Do NOT render or reformat it yourself.
  |
  |  6. In the same reply, include:
  |       a. The verbatim human-readable trace (step 5 above).
  |       b. A summary of every field you read (node index, class, field name,
  |          observed value) and every source file or URL you consulted.
  |       c. The retained size from step 4, and whether it is exact or a lower bound.
  |       d. Your conclusion: what holds what, through which field, why the
  |          reference was not cleared, what the fix should be and why.
  |
  |  7. You are done, close the session with the "close-session" command.
  |
  |MULTIPLE LEAK GROUPS
  |
  |  "summary" lists all groups. Each group is a distinct bug signature.
  |  Use "select-group N" and "select-trace N" to navigate.
  |
  |JSON SCHEMA — trace commands
  |
  |  {
  |    "group": <int>,
  |    "traceInstance": <int>,
  |    "overrides": <int>,
  |    "progressPct": <int>,            0-100; 100 = WIN CONDITION reached
  |    "suspectWindowStart": <int>,     index of first suspect reference (-1 = none)
  |    "leakFound": <bool>,             true when progressPct == 100
  |    "culpritReferenceIndex": <int>,  index of the bad reference (-1 = not yet known)
  |    "firstLeakingObjectId": <long>,  objectId of the first LEAKING node (-1 = none yet)
  |    "key": "<string>",               KeyedWeakReference key that uniquely identifies this leaking object instance.
  |                                     Match this value against the key shown in a leak report to confirm
  |                                     you are investigating the correct instance.
  |    "nodes": [
  |      {
  |        "index": <int>,              0 = GC root, last = leaking object
  |        "objectId": <long>,          use with: fields @ID  string @ID  referrers @ID
  |        "className": "<string>",
  |        "leakingStatus": "LEAKING|NOT_LEAKING|UNKNOWN",
  |        "leakingStatusReason": "<string>",
  |        "isSuspect": <bool>          true = outgoing reference is a suspect (~)
  |      }
  |    ]
  |  }
  |
  |  fields / node  → { "fields":[...] }  or  { "traceIndex":N, ... }
  |  instances      → { "count":<int>, "instances":[{ "objectId":<long> }] }
  |  retained-size  → { "objectId":<long>, "retainedObjectCount":<int>, "retainedSize":"<string>", "retainedSizeBytes":<long> }
  |
  |ENDING THE SESSION
  |
  |  Always close the session when done:
  |    shark-ai-investigate cmd <shortcode> close-session
  |  This stops the daemon and cleans up the named pipes.
""".trimMargin()

// ---------------------------------------------------------------------------
// Session state — holds the heap graph and all mutable investigation state.
// All command handling lives here so that no function needs to pass graph around.
// ---------------------------------------------------------------------------

@Suppress("TooManyFunctions")
private class SessionState(
  val graph: HeapGraph,
  private val session: LeakInvestigationSession,
  val analysis: InitialAnalysis,
  private val heapDumpPath: String,
) {
  var currentGroupIndex = 0
  var currentTraceIndex = 0

  /**
   * Heap object ID → (leakingStatus, reason). Shared across all traces in the session so that
   * overrides for objects appearing in multiple paths carry over when switching traces.
   */
  val statusOverrides = mutableMapOf<Long, Pair<LeakingStatus, String>>()
  var currentTrace: LeakTrace = reinspect()

  // ---------------------------------------------------------------------------
  // FIFO daemon loop
  // ---------------------------------------------------------------------------

  fun runDaemon(inPath: String, outPath: String) {
    while (true) {
      // Opening a FIFO blocks until both ends are open: open(RDONLY) blocks until
      // another process opens the same path with open(WRONLY), and vice versa.
      // The daemon needs to open two FIFOs — inPath for read and outPath for write.
      // If we opened them sequentially the daemon would block on the first open,
      // and if the client happened to open the second FIFO first, both sides would
      // be waiting on the other to open the first one — a deadlock.
      //
      // The fix: start both opens concurrently via CompletableFuture so the daemon
      // is always waiting on both FIFOs simultaneously. The client can then open
      // them in any order and will always unblock one future first. The common
      // fork-join pool used by supplyAsync uses daemon threads, so a SIGTERM while
      // blocking here does not keep the JVM alive. get() returns non-null directly.
      val readerFuture = CompletableFuture.supplyAsync { File(inPath).bufferedReader() }
      val writerFuture =
        CompletableFuture.supplyAsync { FileOutputStream(outPath).bufferedWriter() }
      val reader = readerFuture.get()
      val writer = writerFuture.get()

      val cmd = reader.use { it.readLine()?.trim() }

      if (cmd == null) {
        writer.close()
        continue
      }

      val response = handleCommand(cmd)
      try {
        writer.use {
          it.write(response + "\n")
          it.flush()
        }
      } catch (_: IOException) {
        // Client disconnected before reading the response — ignore and loop.
      }

      if (cmd == "close-session") break
    }
  }

  // ---------------------------------------------------------------------------
  // Command dispatch
  // ---------------------------------------------------------------------------

  fun handleCommand(cmd: String): String {
    if (cmd.isBlank() || cmd == "help") return Json.encodeToString(HelpResponse(INSTRUCTIONS))
    val parts = cmd.split("\\s+".toRegex(), limit = 3)
    return try {
      when (parts[0]) {
        "ping" -> Json.encodeToString(PingResponse(heapDumpPath))
        "close-session" -> Json.encodeToString(CloseSession("Session closed."))
        "summary" -> Json.encodeToString(buildSummary())
        "node" -> Json.encodeToString(nodeResponse(parts))
        "fields" -> Json.encodeToString(fieldsResponse(parts))
        "instances" -> Json.encodeToString(instancesResponse(parts))
        "string" -> Json.encodeToString(stringResponse(parts))
        "referrers" -> Json.encodeToString(referrersResponse(parts))
        "retained-size" -> Json.encodeToString(retainedSizeResponse(parts))
        "human-readable-trace" -> Json.encodeToString(HumanReadableTraceResponse(currentTrace.toString()))
        "trace",
        "mark-leaking",
        "mark-not-leaking",
        "mark-unknown",
        "select-group",
        "select-trace" -> {
          when (parts[0]) {
            "mark-leaking" -> applyMark(parts, LEAKING)
            "mark-not-leaking" -> applyMark(parts, NOT_LEAKING)
            "mark-unknown" -> applyMarkUnknown(parts)
            "select-group" -> applySelectGroup(parts)
            "select-trace" -> applySelectTrace(parts)
          }
          Json.encodeToString(buildTrace())
        }

        else -> Json.encodeToString(ErrorResponse("Unknown command: ${parts[0]}"))
      }
    } catch (e: CmdError) {
      e.json
    } catch (e: Exception) {
      Json.encodeToString(ErrorResponse("Internal error: ${e.javaClass.simpleName}: ${e.message}"))
    }
  }

  // ---------------------------------------------------------------------------
  // Command handlers
  // ---------------------------------------------------------------------------

  private fun nodeResponse(parts: List<String>): NodeResponse {
    val index = requireTraceIndex(parts)
    val objectId = currentCachedPath().objectIds[index]
    val obj =
      graph.findObjectByIdOrNull(objectId) ?: cmdError("Object @$objectId not found in heap")
    val traceObj = traceNodeAt(index)
    return NodeResponse(
      traceIndex = index,
      objectId = objectId,
      className = renderObjectClass(obj),
      leakingStatus = traceObj.leakingStatus.toString(),
      leakingStatusReason = traceObj.leakingStatusReason,
      labels = traceObj.labels.toList()
    )
  }

  private fun fieldsResponse(parts: List<String>): FieldsResponse {
    val arg = parts.getOrNull(1) ?: cmdError("Usage: fields N  or  fields @ID")
    val obj = resolveObjectArg(arg)
    if (obj !is HeapInstance) cmdError("Not an instance: ${renderObjectClass(obj)}")
    val fields = obj.readFields().map { f ->
      FieldEntry(
        declaringClass = f.declaringClass.name, name = f.name, value = renderValueJson(f.value)
      )
    }.toList()
    return FieldsResponse(objectId = obj.objectId, fields = fields)
  }

  private fun instancesResponse(parts: List<String>): InstancesResponse {
    val className = parts.getOrNull(1) ?: cmdError("Usage: instances CLASS_NAME")
    val clazz = graph.findClassByName(className) ?: cmdError("Class not found: $className")
    val instances = clazz.instances.map { InstanceEntry(it.objectId) }.toList()
    return InstancesResponse(className = className, count = instances.size, instances = instances)
  }

  private fun stringResponse(parts: List<String>): StringResponse {
    val arg = parts.getOrNull(1) ?: cmdError("Usage: string @ID")
    return StringResponse((resolveObjectArg(arg) as? HeapInstance)?.readAsJavaString())
  }

  private fun referrersResponse(parts: List<String>): ReferrersResponse {
    val arg = parts.getOrNull(1) ?: cmdError("Usage: referrers @ID")
    val targetId = parseObjectId(arg)
    val referrers = graph.instances.filter { instance ->
      instance.readFields().any { field ->
        val holder = field.value.holder
        holder is ReferenceHolder && !holder.isNull && holder.value == targetId
      }
    }.map { ReferrerEntry(it.objectId, it.instanceClassName) }.toList()
    return ReferrersResponse(targetId = targetId, count = referrers.size, referrers = referrers)
  }

  private fun retainedSizeResponse(parts: List<String>): RetainedSizeResponse {
    val arg = parts.getOrNull(1) ?: cmdError("Usage: retained-size @ID")
    val targetId = parseObjectId(arg)
    graph.findObjectByIdOrNull(targetId) ?: cmdError("Object @$targetId not found")
    val result = SingleObjectRetainedSizeCalculator(graph).computeRetainedSize(targetId)
    return RetainedSizeResponse(
      objectId = result.objectId,
      retainedObjectCount = result.retainedObjectCount,
      retainedSize = result.retainedSize.toString(),
      retainedSizeBytes = result.retainedSize.inWholeBytes
    )
  }

  private fun applyMark(parts: List<String>, status: LeakingStatus) {
    val index = requireTraceIndex(parts)
    val reason = parts.getOrElse(2) { "marked by agent" }
    statusOverrides[currentCachedPath().objectIds[index]] = status to reason
    currentTrace = reinspect()
  }

  private fun applyMarkUnknown(parts: List<String>) {
    statusOverrides.remove(currentCachedPath().objectIds[requireTraceIndex(parts)])
    currentTrace = reinspect()
  }

  private fun applySelectGroup(parts: List<String>) {
    val n = parts.getOrNull(1)?.toIntOrNull() ?: cmdError("Usage: select-group N")
    if (n !in analysis.allLeaks.indices) {
      cmdError("Invalid group $n. Range: 0..${analysis.allLeaks.lastIndex}")
    }
    currentGroupIndex = n
    currentTraceIndex = 0
    currentTrace = reinspect()
  }

  private fun applySelectTrace(parts: List<String>) {
    val n = parts.getOrNull(1)?.toIntOrNull() ?: cmdError("Usage: select-trace N")
    val max = currentLeak().leakTraces.lastIndex
    if (n !in 0..max) cmdError("Invalid trace $n. Range: 0..$max")
    currentTraceIndex = n
    currentTrace = reinspect()
  }

  // ---------------------------------------------------------------------------
  // Response builders
  // ---------------------------------------------------------------------------

  fun buildSummary(): SummaryResponse {
    val groups = analysis.allLeaks.mapIndexed { i, leak ->
      LeakGroupEntry(
        index = i,
        type = if (leak is LibraryLeak) "library" else "application",
        description = leak.shortDescription,
        instances = leak.leakTraces.size
      )
    }
    return SummaryResponse(groups)
  }

  fun buildTrace(): TraceResponse {
    val path = currentCachedPath()
    val allNodes = currentTrace.referencePath.map { it.originObject } +
      listOf(currentTrace.leakingObject)

    val suspectWindowStart = currentTrace.referencePath.indices
      .firstOrNull { i -> currentTrace.referencePathElementIsSuspect(i) }
      ?: -1

    val unknownCount = allNodes.count { it.leakingStatus == LeakingStatus.UNKNOWN }
    val progressPct = (allNodes.size - unknownCount) * 100 / allNodes.size

    val leakFound = unknownCount == 0
    val culpritIdx = if (leakFound) {
      currentTrace.referencePath.indices
        .firstOrNull { i -> currentTrace.referencePathElementIsSuspect(i) }
        ?: -1
    } else {
      -1
    }

    val nodes = allNodes.mapIndexed { i, node ->
      val objectId = path.objectIds[i]
      val isSuspect = i < currentTrace.referencePath.size &&
        currentTrace.referencePathElementIsSuspect(i)
      TraceNodeEntry(
        index = i,
        objectId = objectId,
        className = node.className,
        leakingStatus = node.leakingStatus.toString(),
        leakingStatusReason = node.leakingStatusReason,
        isSuspect = isSuspect
      )
    }

    val firstLeakingObjectId = nodes
      .firstOrNull { it.leakingStatus == LeakingStatus.LEAKING.toString() }
      ?.objectId ?: -1L

    return TraceResponse(
      group = currentGroupIndex,
      traceInstance = currentTraceIndex,
      overrides = statusOverrides.size,
      progressPct = progressPct,
      suspectWindowStart = suspectWindowStart,
      leakFound = leakFound,
      culpritReferenceIndex = culpritIdx,
      firstLeakingObjectId = firstLeakingObjectId,
      key = currentTrace.leakingObject.labels
        .first { it.startsWith("key = ") }
        .removePrefix("key = "),
      nodes = nodes
    )
  }

  // ---------------------------------------------------------------------------
  // Value rendering helpers
  // ---------------------------------------------------------------------------

  private fun renderObjectClass(obj: HeapObject): String = when (obj) {
    is HeapInstance -> obj.instanceClassName
    is HeapClass -> obj.name
    is HeapObjectArray -> obj.arrayClassName
    is HeapPrimitiveArray -> obj.arrayClassName
  }

  private fun renderValueJson(value: HeapValue): JsonElement {
    val holder = value.holder
    return when {
      holder is ReferenceHolder && holder.isNull -> JsonNull
      holder is ReferenceHolder -> {
        val obj = value.asObject
        buildJsonObject {
          put("objectId", holder.value)
          if (obj != null) put("class", renderObjectClass(obj))
        }
      }

      else -> JsonPrimitive(holder.toString())
    }
  }

  // ---------------------------------------------------------------------------
  // State helpers
  // ---------------------------------------------------------------------------

  private fun currentLeak(): Leak = analysis.allLeaks[currentGroupIndex]

  private fun currentCachedPath(): CachedPath =
    analysis.groupedPaths[currentGroupIndex][currentTraceIndex]

  private fun reinspect(): LeakTrace =
    session.reinspectPath(graph, currentCachedPath(), statusOverrides)

  private fun traceNodeAt(index: Int): LeakTraceObject {
    val allNodes = currentTrace.referencePath.map { it.originObject } +
      listOf(currentTrace.leakingObject)
    return allNodes[index]
  }

  @Suppress("ThrowsCount")
  private fun requireTraceIndex(parts: List<String>): Int {
    val raw = parts.getOrNull(1) ?: cmdError("Usage: ${parts[0]} N")
    val index = raw.toIntOrNull() ?: cmdError("Expected integer, got: $raw")
    val max = currentCachedPath().objectIds.lastIndex
    if (index !in 0..max) cmdError("Index $index out of range (0..$max)")
    return index
  }

  @Suppress("ThrowsCount")
  private fun resolveObjectArg(arg: String): HeapObject {
    return if (arg.startsWith("@")) {
      val id = parseObjectId(arg)
      graph.findObjectByIdOrNull(id) ?: cmdError("Object @$id not found")
    } else {
      val index = arg.toIntOrNull()
        ?: cmdError("Expected trace node index N or @ID, got: $arg")
      val max = currentCachedPath().objectIds.lastIndex
      if (index !in 0..max) cmdError("Index $index out of range (0..$max)")
      val id = currentCachedPath().objectIds[index]
      graph.findObjectByIdOrNull(id) ?: cmdError("Object @$id not found")
    }
  }

  private fun parseObjectId(arg: String): Long =
    arg.removePrefix("@").toLongOrNull() ?: cmdError("Invalid object ID: $arg")
}

@Serializable private data class PingResponse(val heapDumpPath: String)

@Serializable private data class HumanReadableTraceResponse(val trace: String)

@Serializable private data class HelpResponse(val help: String)

@Serializable private data class CloseSession(val message: String)

@Serializable private data class ErrorResponse(val error: String)

private class CmdError(val json: String) : Exception(json)

private fun cmdError(msg: String): Nothing = throw CmdError(Json.encodeToString(ErrorResponse(msg)))

@Serializable
private data class NodeResponse(
  val traceIndex: Int,
  val objectId: Long,
  val className: String,
  val leakingStatus: String,
  val leakingStatusReason: String,
  val labels: List<String>
)

@Serializable
private data class FieldEntry(
  @SerialName("class") val declaringClass: String,
  val name: String,
  val value: JsonElement
)

@Serializable
private data class FieldsResponse(
  val objectId: Long,
  val fields: List<FieldEntry>
)

@Serializable private data class InstanceEntry(val objectId: Long)

@Serializable
private data class InstancesResponse(
  val className: String,
  val count: Int,
  val instances: List<InstanceEntry>
)

@Serializable private data class StringResponse(val value: String?)

@Serializable
private data class ReferrerEntry(
  val objectId: Long,
  @SerialName("class") val className: String
)

@Serializable
private data class ReferrersResponse(
  val targetId: Long,
  val count: Int,
  val referrers: List<ReferrerEntry>
)

@Serializable
private data class RetainedSizeResponse(
  val objectId: Long,
  val retainedObjectCount: Int,
  val retainedSize: String,
  val retainedSizeBytes: Long
)

@Serializable
private data class LeakGroupEntry(
  val index: Int,
  val type: String,
  val description: String,
  val instances: Int
)

@Serializable private data class SummaryResponse(val leakGroups: List<LeakGroupEntry>)

@Serializable
private data class TraceNodeEntry(
  val index: Int,
  val objectId: Long,
  val className: String,
  val leakingStatus: String,
  val leakingStatusReason: String,
  val isSuspect: Boolean
)

@Serializable
private data class TraceResponse(
  val group: Int,
  val traceInstance: Int,
  val overrides: Int,
  val progressPct: Int,
  val suspectWindowStart: Int,
  val leakFound: Boolean,
  val culpritReferenceIndex: Int,
  val firstLeakingObjectId: Long,
  val key: String,
  val nodes: List<TraceNodeEntry>
)
